# Ответы на вопросы
### Что такое UUID?
UUID (Universally Unique Identifier) — это 128-битное число, используемое для идентификации информации. UUID гарантирует уникальность идентификатора без необходимости обращения к штуке, которая регистрирует id. Вероятность создания двух одинаковых UUID крайне мала, что делает их идеальными для идентификации объектов.
### Является ли такая предложенная мной архитектура нормальной? Предложите улучшения.
Предложенная архитектура является довольно хорошей.

**Возможные улучшения:**
-   **Статус транзакции:** В объект транзакции стоит добавить поле "статус" (например, "в обработке", "выполнена", "отклонена"). Это поможет отслеживать жизненный цикл операции.
-   **Сервисный слой:** Логику обработки транзакций (проверки, изменение балансов) лучше вынести в отдельный слой сервисов (например, TransactionService), а не хранить её внутри моделей данных. Это соответствует принципам SOLID и делает структуру проекта красивее. 

Собственно эти изменения я и добавил в проект.

### Что в языке программирования JAVA позволяет добиться атомарности и какие паттерны тут можно использовать?

Для достижения атомарности и безопасной работы в многопоточной среде в Java используются следующие механизмы и паттерны:

-   **synchronized:** Позволяет сделать методы или блоки кода потокобезопасными, гарантируя, что только один поток может выполнять защищенный код в один момент времени для конкретного объекта.
    
-   **Всякие Locks:** Пакет java.util.concurrent.locks (например, ReentrantLock) предоставляет более гибкие и мощные механизмы блокировки по сравнению с synchronized.
    
-   **Атомарные переменные:** Классы из пакета java.util.concurrent.atomic (например, AtomicInteger, AtomicLong) предоставляют возможность выполнять атомарные операции над примитивными типами данных без использования явных блокировок.
    
-   **Транзакции в JDBC/JPA:** При работе с базами данных стандартным подходом является использование транзакций, которые гарантируют атомарность на уровне СУБД. Фреймворки, такие как Spring, значительно упрощают управление такими транзакциями с помощью аннотации @Transactional.

- **Ну и всякие другие штуки из java.util.concurrent**
    
**Паттерны:**

-   **Producer-Consumer:** Этот паттерн подходит для асинхронной обработки. Запросы на транзакции (от "производителей") помещаются в потокобезопасную очередь (например, BlockingQueue), а один или несколько потоков-"потребителей" извлекают их из очереди и последовательно обрабатывают.
    
-   **Command (Команда):** Каждая транзакция может быть инкапсулирована в объект-команду. Эти объекты можно помещать в очередь для асинхронного выполнения, а также легко логировать, отменять или повторять.

# Как настроить запуск из Intellij Idea
В разных лабах у меня различные системы сборки (в этой лабе maven из-за драйвера базы данных), поэтому структура всего проекта нестандартная

 1. Открываем Edit Configutations запуска
 2. Добавляем Maven
 3. Ставим корневую папку ...ryzhov/Lab_2
 4. Ставим Run как `compile exec:java`
 5. И всё, ну там по надобности синхронизировать maven

# Примеры использования принципов SOLID в моей лабе

 - **S**  Классы DAO: Их единственная задача — это взаимодействие с базой данных для конкретной сущности.
 - **O** Паттерн Стратегия (TransactionStrategy и TransactionService):  Закрыт для изменения: пусть банк захотел добавить новую операцию — "Оплата счетов". Нам не нужно изменять ни строчки в уже отлаженном и работающем классе TransactionService. Открыт для расширения: мы просто создаем новый класс BillPaymentStrategy implements TransactionStrategy, реализуем в нем логику оплаты счетов и добавляем одну строку в конструктор TransactionService для его регистрации.
 - **L** Все реализации TransactionStrategy. TransactionService работает с переменной TransactionStrategy strategy. Ему все равно, какой именно конкретный объект там находится, главное - он соответствует контракту.
- **I** А нету примеров. В этом проекте сложно было его нарушить ввиду отсутствия больших интерфейсов.
- **D** Модуль высокого уровня TransactionService не создаёт реализации DAO, а получает их через конструктор.

# Примеры использования паттернов в моей лабе
На этом моменте я сильно устал писать этот файл, думаю там уже понятно какие я паттерны юзал. Их там много в пакете lab2.bank.service

